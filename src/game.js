// Generated by CoffeeScript 1.8.0
(function() {
  var BadFlag, Board, ExplodedMine, Flag, FlaggedMine, Mine, StateManager, TextTile, Tile,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Tile = (function() {
    function Tile(ctx, x, y) {
      this.ctx = ctx;
      this.x = x;
      this.y = y;
      this.mouseUpHandler = __bind(this.mouseUpHandler, this);
      this.mouseOutHandler = __bind(this.mouseOutHandler, this);
      this.mouseOverHandler = __bind(this.mouseOverHandler, this);
      this.size = 42;
      this.tileBackground = this.ctx.rect(0, 0, this.size, this.size);
      this.tileBackground.attr({
        fill: '#ddd',
        stroke: 'gray',
        strokeWidth: 1
      });
      this.g = this.ctx.g(this.tileBackground);
      this.g.transform("translate(" + (this.x * this.size) + ", " + (this.y * this.size) + ")");
      this.g.mouseover(this.mouseOverHandler);
      this.g.mouseout(this.mouseOutHandler);
      this.g.mouseup(this.mouseUpHandler);
    }

    Tile.prototype.mouseOverHandler = function(evt) {
      if (!game.state.is(StateManager.GameOver)) {
        return this.tileBackground.attr({
          fill: '#ccc'
        });
      }
    };

    Tile.prototype.mouseOutHandler = function(evt) {
      if (!game.state.is(StateManager.GameOver)) {
        return this.tileBackground.attr({
          fill: '#ddd'
        });
      }
    };

    Tile.prototype.mouseUpHandler = function(evt) {
      var casePosition;
      if (game.state.is(StateManager.GameOver)) {
        return;
      }
      if (game.state.is(StateManager.Empty)) {
        if (evt.button === 0) {
          game.initGame(this.x, this.y);
        }
      }
      if (game.state.is(StateManager.Playing)) {
        if (evt.button === 2) {
          casePosition = game.positionFromCoord(this.x, this.y);
          game.board.cases[casePosition].g.remove();
          if (game.board.cases[casePosition].constructor === Flag) {
            game.flags--;
            game.board.cases[casePosition] = new Tile(this.ctx, this.x, this.y);
          } else {
            game.flags++;
            game.board.cases[casePosition] = new Flag(this.ctx, this.x, this.y);
          }
          return game.board.flagsLbl.attr({
            text: "Flags: " + game.flags + "/" + game.nbMines
          });
        } else {
          return this.showTile();
        }
      }
    };

    Tile.prototype.showTile = function() {
      var casePosition, nbMinesAround, x, y, _i, _len, _ref, _ref1, _results;
      casePosition = game.positionFromCoord(this.x, this.y);
      if (game.board.cases[casePosition].constructor !== Tile) {
        return;
      }
      if (game.data[casePosition] === game.entities.Mine) {
        game.willDie = casePosition;
        return;
      }
      nbMinesAround = this.countMines();
      game.board.cases[casePosition].g.remove();
      game.board.cases[casePosition] = new TextTile(this.ctx, this.x, this.y, nbMinesAround);
      game.safe++;
      if (nbMinesAround === 0) {
        _ref = game.neighborCoord(this.x, this.y);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          _ref1 = _ref[_i], x = _ref1[0], y = _ref1[1];
          _results.push(game.board.cases[game.positionFromCoord(x, y)].showTile());
        }
        return _results;
      }
    };

    Tile.prototype.countMines = function() {
      var nbMines, x, y, _i, _len, _ref, _ref1;
      nbMines = 0;
      _ref = game.neighborCoord(this.x, this.y);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], x = _ref1[0], y = _ref1[1];
        if (game.data[game.positionFromCoord(x, y)] === game.entities.Mine) {
          nbMines++;
        }
      }
      return nbMines;
    };

    Tile.prototype.countFlags = function() {
      var nbFlags, x, y, _i, _len, _ref, _ref1;
      nbFlags = 0;
      _ref = game.neighborCoord(this.x, this.y);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], x = _ref1[0], y = _ref1[1];
        if (game.board.cases[game.positionFromCoord(x, y)].constructor === Flag) {
          nbFlags++;
        }
      }
      return nbFlags;
    };

    return Tile;

  })();

  TextTile = (function(_super) {
    __extends(TextTile, _super);

    function TextTile(ctx, x, y, number) {
      var text;
      this.ctx = ctx;
      this.x = x;
      this.y = y;
      this.number = number;
      this.mouseUpHandler = __bind(this.mouseUpHandler, this);
      this.colors = ['blue', 'green', 'red', 'navy', 'maroon', 'aqua', 'purple', 'black'];
      TextTile.__super__.constructor.apply(this, arguments);
      this.g.unmouseover();
      this.g.unmouseout();
      this.g.unmouseup();
      this.g.mouseup(this.mouseUpHandler);
      this.tileBackground.attr({
        fill: '#fff'
      });
      text = this.ctx.text(this.size / 2, this.size / 2, this.number);
      text.attr({
        fontFamily: 'Arial',
        fontSize: 38,
        alignmentBaseline: 'central',
        textAnchor: 'middle',
        fill: this.colors[this.number - 1]
      });
      this.g.append(text);
    }

    TextTile.prototype.mouseUpHandler = function(evt) {
      var x, y, _i, _len, _ref, _ref1, _results;
      if (game.state.is(StateManager.GameOver)) {
        return;
      }
      if (this.countFlags() === this.countMines()) {
        _ref = game.neighborCoord(this.x, this.y);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          _ref1 = _ref[_i], x = _ref1[0], y = _ref1[1];
          _results.push(game.board.cases[game.positionFromCoord(x, y)].showTile());
        }
        return _results;
      }
    };

    return TextTile;

  })(Tile);

  this.Game = (function() {
    function Game(id) {
      this.gameOver = __bind(this.gameOver, this);
      this.state = new StateManager();
      this.entities = {
        Empty: 0,
        Mine: 1,
        Flag: 2
      };
      this.nbMines = 50;
      this.flags = 0;
      this.safe = 0;
      this.data = [];
      this.willDie = false;
      this.board = new Board(id);
      this.board.createBoard();
    }

    Game.prototype.initGame = function(x, y) {
      this.state.set(StateManager.Playing);
      return this.generateBoard(x, y);
    };

    Game.prototype.rnd = function(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    };

    Game.prototype.neighborCoord = function(x, y) {
      var result;
      result = [];
      if (this.isValidPosition(x - 1, y - 1)) {
        result.push([x - 1, y - 1]);
      }
      if (this.isValidPosition(x - 0, y - 1)) {
        result.push([x - 0, y - 1]);
      }
      if (this.isValidPosition(x + 1, y - 1)) {
        result.push([x + 1, y - 1]);
      }
      if (this.isValidPosition(x - 1, y - 0)) {
        result.push([x - 1, y - 0]);
      }
      if (this.isValidPosition(x + 1, y - 0)) {
        result.push([x + 1, y - 0]);
      }
      if (this.isValidPosition(x - 1, y + 1)) {
        result.push([x - 1, y + 1]);
      }
      if (this.isValidPosition(x - 0, y + 1)) {
        result.push([x - 0, y + 1]);
      }
      if (this.isValidPosition(x + 1, y + 1)) {
        result.push([x + 1, y + 1]);
      }
      return result;
    };

    Game.prototype.around = function(idx, x, y) {
      var item, neighbors, neighborsIdx;
      neighbors = this.neighborCoord(x, y);
      neighborsIdx = [
        (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = neighbors.length; _i < _len; _i++) {
            item = neighbors[_i];
            _results.push(this.positionFromCoord(item[0], item[1]));
          }
          return _results;
        }).call(this)
      ];
      return __indexOf.call(neighborsIdx[0], idx) >= 0 || idx === this.positionFromCoord(x, y) || this.data[idx] === this.entities.Mine;
    };

    Game.prototype.generateBoard = function(x, y) {
      var i, rnd, _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = this.nbMines; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        while (true) {
          rnd = this.rnd(0, (this.board.nbHorizontalTiles * this.board.nbVerticalTiles) - 1);
          if (!this.around(rnd, x, y)) {
            break;
          }
        }
        _results.push(this.data[rnd] = this.entities.Mine);
      }
      return _results;
    };

    Game.prototype.coordFromPosition = function(position) {
      var x, y;
      y = Math.floor(position / this.board.nbHorizontalTiles);
      x = position - y * this.board.nbHorizontalTiles;
      return [x, y];
    };

    Game.prototype.positionFromCoord = function(x, y) {
      var position;
      return position = x + y * this.board.nbHorizontalTiles;
    };

    Game.prototype.isValidPosition = function(x, y) {
      return x >= 0 && x < this.board.nbHorizontalTiles && y >= 0 && y < this.board.nbVerticalTiles;
    };

    Game.prototype.showMines = function(deadPosition) {
      var i, params, x, y, _i, _ref, _ref1, _results;
      _results = [];
      for (i = _i = 0, _ref = this.board.cases.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        _ref1 = this.coordFromPosition(i), x = _ref1[0], y = _ref1[1];
        params = [this.board.board, x, y];
        if (this.data[i] === this.entities.Mine) {
          this.board.cases[i].g.remove();
          if (i === deadPosition) {
            _results.push(this.board.cases[i] = (function(func, args, ctor) {
              ctor.prototype = func.prototype;
              var child = new ctor, result = func.apply(child, args);
              return Object(result) === result ? result : child;
            })(ExplodedMine, params, function(){}));
          } else if (this.board.cases[i].constructor === Flag) {
            _results.push(this.board.cases[i] = (function(func, args, ctor) {
              ctor.prototype = func.prototype;
              var child = new ctor, result = func.apply(child, args);
              return Object(result) === result ? result : child;
            })(FlaggedMine, params, function(){}));
          } else {
            _results.push(this.board.cases[i] = (function(func, args, ctor) {
              ctor.prototype = func.prototype;
              var child = new ctor, result = func.apply(child, args);
              return Object(result) === result ? result : child;
            })(Mine, params, function(){}));
          }
        } else if (this.board.cases[i].constructor === Flag) {
          this.board.cases[i].g.remove();
          _results.push(this.board.cases[i] = (function(func, args, ctor) {
            ctor.prototype = func.prototype;
            var child = new ctor, result = func.apply(child, args);
            return Object(result) === result ? result : child;
          })(BadFlag, params, function(){}));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Game.prototype.gameOver = function(deadPosition) {
      this.state.set(StateManager.GameOver);
      return this.showMines(deadPosition);
    };

    Game.prototype.win = function() {
      var background, winLbl;
      this.state.set(StateManager.Win);
      background = this.board.board.rect(0, 0, 42 * 19, 42 * 13);
      background.attr({
        fill: 'rgba(255, 255, 255, 0.7)'
      });
      winLbl = this.board.board.text(42 * 19 / 2, 42 * 13 / 2, 'Win');
      return winLbl.attr({
        fontSize: 40,
        fontFamily: 'Arial',
        fill: 'green',
        alignmentBaseline: 'central',
        textAnchor: 'middle'
      });
    };

    Game.prototype.reset = function() {
      this.safe = 0;
      this.flags = 0;
      this.data = [];
      this.willDie = false;
      return this.board.reset();
    };

    return Game;

  })();

  StateManager = (function() {
    function StateManager() {
      this.delay = 0;
      this.state = StateManager.Empty;
    }

    StateManager.prototype.is = function(state) {
      return this.state === state;
    };

    StateManager.prototype.set = function(state) {
      return this.state = state;
    };

    StateManager.Empty = 0;

    StateManager.Playing = 1;

    StateManager.GameOver = 2;

    StateManager.Win = 3;

    return StateManager;

  })();

  Board = (function() {
    function Board(id) {
      this.id = id;
      this.mouseUpHandler = __bind(this.mouseUpHandler, this);
      this.board = Snap(this.id);
      this.board.mouseup(this.mouseUpHandler);
      this.nbHorizontalTiles = 19;
      this.nbVerticalTiles = 13;
      this.cases = [];
    }

    Board.prototype.mouseUpHandler = function(evt) {
      if (game.state.is(StateManager.Playing)) {
        if (game.safe === game.board.cases.length - game.nbMines) {
          game.win();
          return;
        }
        if (game.willDie !== false) {
          return game.gameOver(game.willDie);
        }
      } else if (game.state.is(StateManager.Win)) {
        game.reset();
        return game.state.set(StateManager.Empty);
      } else if (game.state.is(StateManager.GameOver)) {
        game.reset();
        return game.state.set(StateManager.Empty);
      }
    };

    Board.prototype.createBoard = function() {
      var i, nbTiles, tmp, x, y, _i;
      nbTiles = this.nbHorizontalTiles * this.nbVerticalTiles;
      for (i = _i = 0; 0 <= nbTiles ? _i < nbTiles : _i > nbTiles; i = 0 <= nbTiles ? ++_i : --_i) {
        y = Math.floor(i / this.nbHorizontalTiles);
        x = i - y * this.nbHorizontalTiles;
        tmp = new Tile(this.board, x, y);
        this.cases[i] = tmp;
      }
      this.flagsLbl = this.board.text(0, 0, "Flags: 0/50");
      return this.flagsLbl.transform('translate(0, 580)');
    };

    Board.prototype.reset = function() {
      this.board.clear();
      return this.createBoard();
    };

    return Board;

  })();

  Flag = (function(_super) {
    __extends(Flag, _super);

    function Flag() {
      Flag.__super__.constructor.apply(this, arguments);
      this.g.append(Flag.render(this.ctx, this.size));
    }

    Flag.render = function(ctx, size) {
      var group, lines, polygon;
      polygon = ctx.polygon([size / 3, size / 2, (size / 3) * 2, size / 3, (size / 3) * 2, (size / 3) * 2]);
      polygon.attr({
        fill: 'red'
      });
      lines = ctx.polyline([(size / 3) * 2, size / 3, (size / 3) * 2, size - (size / 4), size / 2, size - (size / 4), size - (size / 5), size - (size / 4)]);
      lines.attr({
        stroke: 'black',
        strokeWidth: size / 20,
        fill: 'transparent'
      });
      group = ctx.g(polygon, lines);
      return group;
    };

    return Flag;

  })(Tile);

  Mine = (function(_super) {
    __extends(Mine, _super);

    function Mine() {
      var circle, group;
      Mine.__super__.constructor.apply(this, arguments);
      circle = this.ctx.circle(this.size / 2, this.size / 2, this.size / 4);
      circle.attr({
        fill: '#666',
        stroke: '#333',
        strokeWidth: 1
      });
      group = this.ctx.g(circle);
      this.g.append(group);
    }

    return Mine;

  })(Tile);

  ExplodedMine = (function(_super) {
    __extends(ExplodedMine, _super);

    function ExplodedMine() {
      var circle, group;
      ExplodedMine.__super__.constructor.apply(this, arguments);
      circle = this.ctx.circle(this.size / 2, this.size / 2, this.size / 4);
      circle.attr({
        fill: '#c00',
        stroke: '#333',
        strokeWidth: 1
      });
      group = this.ctx.g(circle);
      this.g.append(group);
    }

    return ExplodedMine;

  })(Tile);

  FlaggedMine = (function(_super) {
    __extends(FlaggedMine, _super);

    function FlaggedMine() {
      FlaggedMine.__super__.constructor.apply(this, arguments);
      this.g.append(Flag.render(this.ctx, this.size));
    }

    return FlaggedMine;

  })(Mine);

  BadFlag = (function(_super) {
    __extends(BadFlag, _super);

    function BadFlag() {
      var group, line1, line2;
      BadFlag.__super__.constructor.apply(this, arguments);
      line1 = this.ctx.line(this.size / 5, this.size / 5, this.size - this.size / 5, this.size - this.size / 5);
      line1.attr({
        stroke: '#000',
        strokeWidth: this.size / 20
      });
      line2 = this.ctx.line(this.size / 5, this.size - this.size / 5, this.size - this.size / 5, this.size / 5);
      line2.attr({
        stroke: '#000',
        strokeWidth: this.size / 20
      });
      group = this.ctx.g(line1, line2);
      this.g.append(group);
    }

    return BadFlag;

  })(Flag);

}).call(this);
