// Generated by CoffeeScript 1.8.0
(function() {
  var BadFlag, Board, ExplodedMine, Flag, FlaggedMine, Mine, States, TextTile, Tile,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Tile = (function() {
    function Tile(ctx, x, y) {
      this.ctx = ctx;
      this.x = x;
      this.y = y;
      this.mouseUpHandler = __bind(this.mouseUpHandler, this);
      this.mouseOutHandler = __bind(this.mouseOutHandler, this);
      this.mouseOverHandler = __bind(this.mouseOverHandler, this);
      this.size = 42;
      this.tileBackground = this.ctx.rect(0, 0, this.size, this.size);
      this.tileBackground.attr({
        fill: '#ddd',
        stroke: 'gray',
        strokeWidth: 1
      });
      this.g = this.ctx.g(this.tileBackground);
      this.g.transform("translate(" + (this.x * this.size) + ", " + (this.y * this.size) + ")");
      this.g.mouseover(this.mouseOverHandler);
      this.g.mouseout(this.mouseOutHandler);
      this.g.mouseup(this.mouseUpHandler);
    }

    Tile.prototype.mouseOverHandler = function(evt) {
      if (!game.state === States.GameOver) {
        return this.tileBackground.attr({
          fill: '#ccc'
        });
      }
    };

    Tile.prototype.mouseOutHandler = function(evt) {
      if (!game.state === States.GameOver) {
        return this.tileBackground.attr({
          fill: '#ddd'
        });
      }
    };

    Tile.prototype.mouseUpHandler = function(evt) {
      var newTileClass, tilePosition;
      if (game.state === States.GameOver) {
        return;
      }
      if (game.state === States.Empty) {
        if (evt.button === 0) {
          game.initGame(this.x, this.y);
        }
      }
      if (game.state === States.Playing) {
        if (evt.button === 2) {
          tilePosition = game.positionFromCoord(this.x, this.y);
          if (game.isFlag(tilePosition)) {
            game.flags--;
            newTileClass = Tile;
          } else {
            game.flags++;
            newTileClass = Flag;
          }
          game.setFlag(this.ctx, this.x, this.y);
          return game.board.flagsLbl.attr({
            text: "Flags: " + game.flags + "/" + game.nbMines
          });
        } else {
          return this.showTile();
        }
      }
    };

    Tile.prototype.showTile = function() {
      var casePosition, nbMinesAround, x, y, _i, _len, _ref, _ref1, _results;
      casePosition = game.positionFromCoord(this.x, this.y);
      if (game.board.cases[casePosition].constructor !== Tile) {
        return;
      }
      if (game.isMine(casePosition)) {
        game.willDie = casePosition;
        return;
      }
      nbMinesAround = this.countMinesAround();
      game.board.cases[casePosition].g.remove();
      game.board.cases[casePosition] = new TextTile(this.ctx, this.x, this.y, nbMinesAround);
      game.safe++;
      if (nbMinesAround === 0) {
        _ref = game.neighborCoord(this.x, this.y);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          _ref1 = _ref[_i], x = _ref1[0], y = _ref1[1];
          _results.push(game.showTile(x, y));
        }
        return _results;
      }
    };

    Tile.prototype.countMinesAround = function() {
      var nbMines, x, y, _i, _len, _ref, _ref1;
      nbMines = 0;
      _ref = game.neighborCoord(this.x, this.y);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], x = _ref1[0], y = _ref1[1];
        if (game.isMine(game.positionFromCoord(x, y))) {
          nbMines++;
        }
      }
      return nbMines;
    };

    Tile.prototype.countFlagsAround = function() {
      var nbFlags, x, y, _i, _len, _ref, _ref1;
      nbFlags = 0;
      _ref = game.neighborCoord(this.x, this.y);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], x = _ref1[0], y = _ref1[1];
        if (game.isFlag(game.positionFromCoord(x, y))) {
          nbFlags++;
        }
      }
      return nbFlags;
    };

    return Tile;

  })();

  TextTile = (function(_super) {
    __extends(TextTile, _super);

    function TextTile(ctx, x, y, number) {
      var text;
      this.ctx = ctx;
      this.x = x;
      this.y = y;
      this.number = number;
      this.mouseUpHandler = __bind(this.mouseUpHandler, this);
      this.colors = ['blue', 'green', 'red', 'navy', 'maroon', 'aqua', 'purple', 'black'];
      TextTile.__super__.constructor.apply(this, arguments);
      this.g.unmouseover();
      this.g.unmouseout();
      this.g.unmouseup();
      this.g.mouseup(this.mouseUpHandler);
      this.tileBackground.attr({
        fill: '#fff'
      });
      text = this.ctx.text(this.size / 2, this.size / 2, this.number);
      text.attr({
        fontFamily: 'Arial',
        fontSize: 38,
        dominantBaseline: 'central',
        textAnchor: 'middle',
        fill: this.colors[this.number - 1]
      });
      this.g.append(text);
    }

    TextTile.prototype.mouseUpHandler = function(evt) {
      var x, y, _i, _len, _ref, _ref1, _results;
      switch (game.state) {
        case States.Playing:
          if (this.countFlagsAround() === this.countMinesAround()) {
            _ref = game.neighborCoord(this.x, this.y);
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              _ref1 = _ref[_i], x = _ref1[0], y = _ref1[1];
              _results.push(game.showTile(x, y));
            }
            return _results;
          }
      }
    };

    return TextTile;

  })(Tile);

  this.Game = (function() {
    function Game(id) {
      this.gameOver = __bind(this.gameOver, this);
      this.state = States.Empty;
      this.entities = {
        Mine: 1
      };
      this.nbMines = 50;
      this.flags = 0;
      this.safe = 0;
      this.data = [];
      this.willDie = false;
      this.board = new Board(id);
      this.board.createBoard();
    }

    Game.prototype.initGame = function(x, y) {
      this.state = States.Playing;
      return this.generateBoard(x, y);
    };

    Game.prototype.rnd = function(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    };

    Game.prototype.setFlag = function(ctx, x, y) {
      var tilePosition;
      tilePosition = this.positionFromCoord(x, y);
      this.board.cases[tilePosition].g.remove();
      return this.board.cases[tilePosition] = new Flag(ctx, x, y);
    };

    Game.prototype.neighborCoord = function(x, y) {
      var dx, dy, result, _i, _j;
      result = [];
      for (dx = _i = -1; _i <= 1; dx = ++_i) {
        for (dy = _j = -1; _j <= 1; dy = ++_j) {
          if (!(dx === 0 && dy === 0)) {
            if (this.isValidPosition(x + dx, y + dy)) {
              result.push([x + dx, y + dy]);
            }
          }
        }
      }
      return result;
    };

    Game.prototype.neighborIdx = function(idx) {
      var item, neighbors, x, y, _ref;
      _ref = this.coordFromPosition(idx), x = _ref[0], y = _ref[1];
      neighbors = this.neighborCoord(x, y);
      return [
        (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = neighbors.length; _i < _len; _i++) {
            item = neighbors[_i];
            _results.push(this.positionFromCoord(item[0], item[1]));
          }
          return _results;
        }).call(this)
      ][0];
    };

    Game.prototype.around = function(idx, x, y) {
      var initialClickPosition, neighborsIdx;
      initialClickPosition = this.positionFromCoord(x, y);
      neighborsIdx = this.neighborIdx(initialClickPosition);
      return __indexOf.call(neighborsIdx, idx) >= 0 || idx === initialClickPosition || this.isMine(idx);
    };

    Game.prototype.generateBoard = function(x, y) {
      var i, rnd, _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = this.nbMines; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        while (true) {
          rnd = this.rnd(0, (this.board.nbHorizontalTiles * this.board.nbVerticalTiles) - 1);
          if (!this.around(rnd, x, y)) {
            break;
          }
        }
        _results.push(this.data[rnd] = this.entities.Mine);
      }
      return _results;
    };

    Game.prototype.showTile = function(x, y) {
      return this.board.cases[this.positionFromCoord(x, y)].showTile();
    };

    Game.prototype.coordFromPosition = function(position) {
      var x, y;
      y = Math.floor(position / this.board.nbHorizontalTiles);
      x = position - y * this.board.nbHorizontalTiles;
      return [x, y];
    };

    Game.prototype.positionFromCoord = function(x, y) {
      var position;
      return position = x + y * this.board.nbHorizontalTiles;
    };

    Game.prototype.isValidPosition = function(x, y) {
      return x >= 0 && x < this.board.nbHorizontalTiles && y >= 0 && y < this.board.nbVerticalTiles;
    };

    Game.prototype.isMine = function(i) {
      return this.data[i] === this.entities.Mine;
    };

    Game.prototype.isFlag = function(i) {
      return this.board.cases[i].constructor === Flag;
    };

    Game.prototype.showMines = function(deadPosition) {
      var i, newTileClass, params, x, y, _i, _ref, _ref1, _results;
      _results = [];
      for (i = _i = 0, _ref = this.board.cases.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        _ref1 = this.coordFromPosition(i), x = _ref1[0], y = _ref1[1];
        params = [this.board.board, x, y];
        if (this.isMine(i) || this.isFlag(i)) {
          this.board.cases[i].g.remove();
          if (i === deadPosition) {
            newTileClass = ExplodedMine;
          } else if (this.isMine(i) && this.isFlag(i)) {
            newTileClass = FlaggedMine;
          } else if (this.isFlag(i)) {
            newTileClass = BadFlag;
          } else {
            newTileClass = Mine;
          }
          _results.push(this.board.cases[i] = (function(func, args, ctor) {
            ctor.prototype = func.prototype;
            var child = new ctor, result = func.apply(child, args);
            return Object(result) === result ? result : child;
          })(newTileClass, params, function(){}));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Game.prototype.gameOver = function(deadPosition) {
      this.state = States.GameOver;
      return this.showMines(deadPosition);
    };

    Game.prototype.win = function() {
      var background, winLbl;
      this.state = States.Win;
      this.showMines();
      background = this.board.board.rect(0, 0, 42 * 19, 42 * 13);
      background.attr({
        fill: 'rgba(255, 255, 255, 0.7)'
      });
      winLbl = this.board.board.text(42 * 19 / 2, 42 * 13 / 2, 'Win');
      return winLbl.attr({
        fontSize: 40,
        fontFamily: 'Arial',
        fill: 'green',
        dominantBaseline: 'central',
        textAnchor: 'middle'
      });
    };

    Game.prototype.reset = function() {
      this.safe = 0;
      this.flags = 0;
      this.data = [];
      this.willDie = false;
      return this.board.reset();
    };

    return Game;

  })();

  States = (function() {
    function States() {}

    States.Empty = 0;

    States.Playing = 1;

    States.GameOver = 2;

    States.Win = 3;

    return States;

  })();

  Board = (function() {
    function Board(id) {
      this.id = id;
      this.mouseUpHandler = __bind(this.mouseUpHandler, this);
      this.board = Snap(this.id);
      this.board.mouseup(this.mouseUpHandler);
      this.nbHorizontalTiles = 19;
      this.nbVerticalTiles = 13;
      this.cases = [];
    }

    Board.prototype.mouseUpHandler = function(evt) {
      switch (game.state) {
        case States.Playing:
          if (game.safe === game.board.cases.length - game.nbMines) {
            return game.win();
          }
          if (game.willDie !== false) {
            return game.gameOver(game.willDie);
          }
          break;
        case States.Win:
          game.reset();
          return game.state = States.Empty;
        case States.GameOver:
          game.reset();
          return game.state = States.Empty;
      }
    };

    Board.prototype.createBoard = function() {
      var i, nbTiles, tmp, x, y, _i;
      nbTiles = this.nbHorizontalTiles * this.nbVerticalTiles;
      for (i = _i = 0; 0 <= nbTiles ? _i < nbTiles : _i > nbTiles; i = 0 <= nbTiles ? ++_i : --_i) {
        y = Math.floor(i / this.nbHorizontalTiles);
        x = i - y * this.nbHorizontalTiles;
        tmp = new Tile(this.board, x, y);
        this.cases[i] = tmp;
      }
      this.flagsLbl = this.board.text(0, 0, "Flags: 0/50");
      return this.flagsLbl.transform('translate(0, 580)');
    };

    Board.prototype.reset = function() {
      this.board.clear();
      return this.createBoard();
    };

    return Board;

  })();

  Flag = (function(_super) {
    __extends(Flag, _super);

    function Flag() {
      Flag.__super__.constructor.apply(this, arguments);
      this.g.append(Flag.render(this.ctx, this.size));
    }

    Flag.render = function(ctx, size) {
      var group, lines, polygon;
      polygon = ctx.polygon([size / 3, size / 2, (size / 3) * 2, size / 3, (size / 3) * 2, (size / 3) * 2]);
      polygon.attr({
        fill: 'red'
      });
      lines = ctx.polyline([(size / 3) * 2, size / 3, (size / 3) * 2, size - (size / 4), size / 2, size - (size / 4), size - (size / 5), size - (size / 4)]);
      lines.attr({
        stroke: 'black',
        strokeWidth: size / 20,
        fill: 'transparent'
      });
      group = ctx.g(polygon, lines);
      return group;
    };

    return Flag;

  })(Tile);

  Mine = (function(_super) {
    __extends(Mine, _super);

    function Mine() {
      var circle, group;
      Mine.__super__.constructor.apply(this, arguments);
      circle = this.ctx.circle(this.size / 2, this.size / 2, this.size / 4);
      circle.attr({
        fill: '#666',
        stroke: '#333',
        strokeWidth: 1
      });
      group = this.ctx.g(circle);
      this.g.append(group);
    }

    return Mine;

  })(Tile);

  ExplodedMine = (function(_super) {
    __extends(ExplodedMine, _super);

    function ExplodedMine() {
      var circle, group;
      ExplodedMine.__super__.constructor.apply(this, arguments);
      circle = this.ctx.circle(this.size / 2, this.size / 2, this.size / 4);
      circle.attr({
        fill: '#c00',
        stroke: '#333',
        strokeWidth: 1
      });
      group = this.ctx.g(circle);
      this.g.append(group);
    }

    return ExplodedMine;

  })(Tile);

  FlaggedMine = (function(_super) {
    __extends(FlaggedMine, _super);

    function FlaggedMine() {
      FlaggedMine.__super__.constructor.apply(this, arguments);
      this.g.append(Flag.render(this.ctx, this.size));
    }

    return FlaggedMine;

  })(Mine);

  BadFlag = (function(_super) {
    __extends(BadFlag, _super);

    function BadFlag() {
      var group, line1, line2;
      BadFlag.__super__.constructor.apply(this, arguments);
      line1 = this.ctx.line(this.size / 5, this.size / 5, this.size - this.size / 5, this.size - this.size / 5);
      line1.attr({
        stroke: '#000',
        strokeWidth: this.size / 20
      });
      line2 = this.ctx.line(this.size / 5, this.size - this.size / 5, this.size - this.size / 5, this.size / 5);
      line2.attr({
        stroke: '#000',
        strokeWidth: this.size / 20
      });
      group = this.ctx.g(line1, line2);
      this.g.append(group);
    }

    return BadFlag;

  })(Flag);

}).call(this);
